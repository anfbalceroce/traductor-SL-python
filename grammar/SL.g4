grammar SL;

start : ('programa' ID)? header* main ;
header : 'const' const+ | 'tipos' tipo_p+ | 'var' var+ ;
var : ID (',' ID)* ':' tipo (';' | '\n' | /* epsilon */)  ;
const : ID '=' expresion (';' | '\n' | /* epsilon */)  ;
tipo_p : ID ':' tipo (';' | '\n' | /* epsilon */)  ;
main : 'inicio' sentencias 'fin' sub  ;
sentencias : sentencia (';' | '\n' | /* epsilon */) next_sentencia  | /* epsilon */  ;
next_sentencia : sentencia (';' | '\n' | /* epsilon */) next_sentencia  | /* epsilon */  ;
sentencia : ID assng_call  | 'si' '(' expresion ')' '{' sentenciasif sino '}'  | 'mientras' '(' expresion ')' '{' sentenciasif '}'  | 'repetir' sentenciasif 'hasta' '(' expresion ')'  | 'eval' '{' 'caso' '(' expresion ')' sentenciasif case sw_sino '}'  | 'desde' for_start '{' sentenciasif '}'  ;
assng_call : '(' params ')'  | id_extend assingment  ;
for_start : ID '=' num_expresion for_end  ;
for_end : 'hasta' num_expresion for_step  ;
for_step : 'paso' num_expresion  | /* epsilon */  ;
sino : 'sino' sino_p  | /* epsilon */  ;
sino_p : sentenciasnoif sino  | 'si' '(' expresion ')' sino_pp sino  ;
sino_pp : sentenciasif  | '{' sentenciasif sino '}' (';' | '\n' | /* epsilon */) next_sentencia  ;
sentenciasnoif : sentencianoif (';' | '\n' | /* epsilon */) next_sentencia  ;
sentencianoif : ID assng_call  | 'mientras' '(' expresion ')' '{' sentenciasif '}'  | 'repetir' sentenciasif 'hasta' '(' expresion ')'  | 'eval' '{' 'caso' '(' expresion ')' sentenciasif case sw_sino '}'  | 'desde' for_start '{' sentenciasif '}'  ;
sentenciasif : sentencia (';' | '\n' | /* epsilon */) next_sentencia  ;
case : 'caso' '(' expresion ')' sentenciasif case  | /* epsilon */  ;
sw_sino : 'sino' sentenciasif  | /* epsilon */  ;
assingment : '=' assingment_p  ;
assingment_p : expresion  | '{' m_expresion '}'  ;
m_expresion : m_term m_expresion_p  | /* epsilon */  ;
m_expresion_p : ',' m_term m_expresion_p  | /* epsilon */  ;
m_term : m_factor  ;
m_factor : '{' m_expresion '}'  | '.' '.' '.'  | expresion  ;
expresion : logic_term logic_expresion_p  ;
logic_expresion_p : 'or' logic_term logic_expresion_p  | /* epsilon */  ;
logic_term : logic_factor logic_term_p  ;
logic_term_p : 'and' logic_factor logic_term_p  | /* epsilon */  ;
logic_factor : logic_element  | 'not' logic_element  ;
logic_element : BOOL  | relation_expresion  ;
relation_expresion : relation_term relation_expresion_p  ;
relation_expresion_p : '<' relation_term relation_expresion_p  | '>' relation_term relation_expresion_p  | '<=' relation_term relation_expresion_p  | '>=' relation_term relation_expresion_p  | '==' relation_term relation_expresion_p  | '<>' relation_term relation_expresion_p  | /* epsilon */  ;
relation_term : num_expresion  ;
num_expresion : num_term num_expresion_p  ;
num_expresion_p : '+' num_term num_expresion_p  | '-' num_term num_expresion_p  | /* epsilon */  ;
num_term : num_factor num_term_p  ;
num_term_p : '*' num_factor num_term_p  | '/' num_factor num_term_p  | '%' num_factor num_term_p  | /* epsilon */  ;
num_factor : num_factor_p  | '+' num_factor_p  | '-' num_factor_p  ;
num_factor_p : base_element num_factor_pp  ;
num_factor_pp : '^' base_element num_factor_pp  | /* epsilon */  ;
base_element : STRING  | NUM  | '(' expresion ')'  | call  ;
sub : 'subrutina' ID '(' args ')' return  | /* epsilon */  ;
args : ref ID (',' ID)* ':' tipo next_arg  | /* epsilon */  ;
next_arg : ';' ref ID (',' ID)* ':' tipo next_arg  | /* epsilon */  ;
ref : 'ref'  | /* epsilon */  ;
return : 'retorna' tipo subheaderr  | subheader  ;
subheader : 'const' const+ subheader  | 'tipos' tipo_p+ subheader  | 'var' var+ subheader  | subbody  ;
subbody : 'inicio' subsentencias 'fin' sub  ;
subheaderr : 'const' const+ subheaderr  | 'tipos' tipo_p+ subheaderr  | 'var' var+ subheaderr  | subbodyr  ;
subbodyr : 'inicio' subsentencias 'retorna' '(' expresion ')' 'fin' sub  ;
subsentencias : sentencia (';' | '\n' | /* epsilon */) next_sentencia  | /* epsilon */  ;
tipo : tipos  | type_vector  | type_matrix  | register  ;
tipos : 'cadena'  | 'logico'  | 'numerico'  | ID  ;
type_vector : 'vector' '[' v_len  ;
v_len : num_expresion ']' tipo  | '*' ']' tipo  ;
type_matrix : 'matriz' '[' dimention_list  ;
dimention_list : '*' next_dimention ']' tipo  | dimention next_dimention ']' tipo  ;
next_dimention : ',' next_dimention_p  | /* epsilon */  ;
next_dimention_p : '*' next_dimention  | dimention next_dimention  ;
dimention : ID  | NUM  ;
register : 'registro' '{' var+ '}'  ;
id_extend : ids_options id_extend  | /* epsilon */  ;
ids_options : '[' num_expresion matrix ']'  | '.' ID  ;
call : ID call_opt  ;
call_opt : '(' params ')'  | id_extend  ;
params : expresion next_param  | /* epsilon */  ;
next_param : ',' expresion next_param  | /* epsilon */  ;
matrix : ',' num_expresion matrix  | /* epsilon */  ;


ID : 	[a-zA-Z\u00F1\u00D1_] [a-zA-Z\u00F1\u00D1_0-9]* ;
NUM : [0-9]+('.'[0-9])?[0-9]*([eE][+-]?[0-9])?[0-9]*;
STRING : '"' ~["\n]* '"' | '\'' ~['\n]* '\'';
BOOL : 'TRUE'  | 'FALSE'  | 'SI'  | 'NO'  ;
COMMENT1 : '//' ~[\n]* -> skip;
COMMENT2 :  '/*' .*? '*/' -> skip;
ESP : [ \t\r\n]+ -> skip ;